This is from the original package.json:

  "devDependencies": {
    "concurrently": "^5.1.0"
  }

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

This is from the old package.json in the server directory:

    "dependencies": {
        "bcrypt": "^5.0.0",
        "express": "^4.17.1",
        "jsonwebtoken": "^8.5.1",
        "mongoose": "^5.9.10"
    },

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
From old clent package.json

      "jwt-decode": "^2.2.0",

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AUTH FILE IDEA:

Checks for a session, and if none is activated, changes the window location to the 
login page. This could run automatically on loading for almost any componant, to ensure 
that the page renders only if the user is logged in, and if not, changing the window
location to the login page so that they can log in. 

OR saves a session and some of it's data to a localstorage component, or something like that..
OR send the session via an API route to the front end and 'fetch' it when a user logs 
in to the front end.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’

RECIPE file:

const { Schema, model } = require('mongoose');

const RecipeSchema = new Schema(
    {
        name: {
            type: String,
            required: true,
            trim: true
        },
        ingredients: {
            type: [String],
            trim: true
        },
        instructions: {
            type: [String],
            trim: true
        }
    },
    {
        toJSON: {
            virtuals: true,
            getters: true
        }
    }
)

const Recipe = model('Recipe', RecipeSchema);

module.exports = Recipe;



USER file

const { Schema, model } = require('mongoose');
const bcrypt = require('bcrypt');

//user schema
const UserSchema = new Schema(
    {
        username: {
            type: String,
            required: true,
            trim: true
        },
        email: {
            type: String,
            required: true,
            unique: true,
            match: [/.+@.+\..+/, 'You must enter a valid email address! Example: john@email.com']
        },
        password: {
            type: String,
            required: true,
            minLength: 8
        },
        savedRecipes: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Recipe'
            }
        ],
        savedLinks: [
            {
                type: Schema.Types.ObjectId,
                ref: 'Link'
            }
        ]
    },
    {
        toJSON: {
            virtuals: true,
            getters: true
        }
    }
);

//hash the password for new users
UserSchema.pre('save', async function(next) {
    if(this.isNew) {
        this.password = await bcrypt.hash(this.password, 15);
    }

    next();
});

//compare an incoming password to it's hashed version for logins
UserSchema.methods.isCorrectPassword = async function(password) {
    return bcrypt.compare(password, this.password)
};

const User = model('User', UserSchema);

module.exports = User;


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰ğŸ‰

User Routes PRE update 

const router = require('express').Router();
const { User } = require('../models');

router.get('/', (req, res) => {
    User.find({})
    .select('-__v -password')
    .then(userData => res.json(userData))
    .catch(err => {
        console.log(err);
        res.status(500).json(err);
    });
});

router.post('/', (req, res) => {
    User.create({
        username: req.body.username,
        password: req.body.password,
        email: req.body.email
    })
    .then(userData => {
        req.session.save(() => {
            req.session.user_id = userData.id;
            req.session.username = userData.username;
            req.session.loggedIn = true;

            res.json({ message: ' ğŸŒğŸŒğŸŒ This worked! Log in completed. ğŸ’ğŸ’ğŸ’', session: req.session })
        })
    })
    .catch(err => {
        console.log(err);
        res.status(500).json(err)
    })
})

router.post('/login', (req, res) => {
    User.findOne({
        email: req.body.email
    })
    .then(userData => {

        if(!userData) {
            res.status(400).json({ message: 'There is no user with this email address!' })
            return
        }

        const validPassword = userData.isCorrectPassword(req.body.password)

        if(!validPassword) {
            res.status(400).json({ message: 'Incorrect password! Try again.' });
            return;
        }

        req.session.save(() => {
            req.session.user_id = userData.id;
            req.session.username = userData.username;
            req.session.loggedIn = true;

            // TODO: Could add a util later that just checks if the logged in is 'true' or 'false' to use on the fron end, and check for the session to be created and active.

            res.json({ message: 'ğŸŒğŸŒğŸŒ This worked! Log in completed. ğŸ’ğŸ’ğŸ’', session: req.session })
        });
    });
});

router.post('/logout', (req, res) => {
    if(req.session.loggedIn) {
        req.session.destroy(() => {
            res.status(204).end();
        })
    } else {
        res.status(404).end();
    }
});

//TODO: Added for development purposes. Route can be deleted at a later time.
router.delete('/:id', (req, res) => {
    User.remove({
        _id: req.params.id
    })
    .then(userData => res.json(userData))
})

module.exports = router;

ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’ğŸ’
